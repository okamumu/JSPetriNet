options{
    STATIC=false;
}

PARSER_BEGIN (JSPetriNetParser)

package jspetrinet.parser;
import jspetrinet.ast.*;
import jspetrinet.exception.*;
import jspetrinet.petri.*;
import jspetrinet.dist.*;

public class JSPetriNetParser {
	private Net current;
	private Net global;

	public void setNet(Net global) {
		this.global = global;
		this.current = global;
	}
}

PARSER_END (JSPetriNetParser)

SKIP: {
	" " | "\t"
	| "/*" : WithinComment
}

<WithinComment> SKIP: {
	"*/" : DEFAULT
}

<WithinComment> MORE: {
	<~[]>
}

TOKEN: {
	<PLACE: "place">
	| <EXPTRANS: "exp">
	| <IMMTRANS: "imm">
	| <GENTRANS: "gen">
	| <GENCONSTTRANS: "gen.const">
	| <GENUNIFTRANS: "gen.unif">
	| <ARC: "arc">
	| <IARC: "iarc">
	| <OARC: "oarc">
	| <HARC: "harc">
	| <IFELSE: "ifelse">
	| <TO: "to">
	| <NET: "net">
	| <MARK: "mark">
	| <BEGIN: "{">
	| <END: "}">
	| <COMMENT: "//" (~["\n", "\r"])*>
	| <REAL: (["0"-"9"])*"."(["0"-"9"])+(["e","E"])?(["+","-"])?(["0"-"9"])*>
	| <INTEGER: (["0"-"9"])+>
  | <BOOLEAN: "true" | "false" | "True" | "False" | "TRUE" | "FALSE" >
	| <STRING: "\""(~["\""])+"\"">
	| <PLUS: "+">
	| <MINUS: "-">
	| <MULTIPLY: "*">
	| <DIVIDE: "/">
	| <MOD: "%">
	| <OR: "||">
	| <AND: "&&">
	| <NOT: "!">
	| <EQ: "==">
	| <NEQ: "!=">
	| <GT: ">">
	| <LT: "<">
	| <GTE: ">=">
	| <LTE: "<=">
	| <IDENTIFIER: ["A"-"Z", "a"-"z", "_"](["0"-"9", "A"-"Z", "a"-"z", "_", "."])*>
	| <GLOBAL_NTOKEN: "##">
	| <NTOKEN: "#">
  | <ECOND: "?">
	| <OPEN: "(">
	| <CLOSE: ")">
	| <NL: "\r\n" | "\n" | "\r">
	| <SEND: ";">
}

void makeNet() throws ASTException: {
} {
	((Statement())? (<COMMENT>)? (<SEND>|<NL>))*
}

void Statement() throws ASTException: {} {
	 block()
	| Declaration()
	| Expression()
}

void block() throws ASTException: {} {
	bbegin() makeNet() bend()
}

void bbegin() throws ASTException: {} {
	<BEGIN> (Statement())? (<COMMENT>)? (<SEND>|<NL>)
}

void bend() throws ASTException: {} {
	<END> (<SEND>|<NL>)
}

void Declaration() throws ASTException: {} {
	NetDeclaration()
	| PlaceDeclaration()
	| ExpTransDeclaration()
	| ImmTransDeclaration()
	| GenTransDeclaration()
	| GenConstTransDeclaration()
	| GenUnifTransDeclaration()
	| ArcDeclaration()
	| IArcDeclaration()
	| OArcDeclaration()
	| HArcDeclaration()
}

void NetDeclaration() throws ASTException: {
	Token token;
} {
	<NET> token = <IDENTIFIER> {
		if (current.contains(token.image)) {
			current = current.getChild(token.image);
		} else {
			Net tmp = new Net(current, token.image);
			current = tmp;
		}
	}
	(<NL>)?
	block()
	{
		current = current.getOuter();
	}
}

void PlaceDeclaration() throws ASTException: {
	Token token;
	PairValueList optlist;
	Place p;
	int pmax;
} {
	<PLACE> token = <IDENTIFIER> {
		pmax = Place.DefaultMax;
//		p = current.createPlace(token.image, Place.DefaultMax);
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			Object value = pval.getValue().eval(current);
			if (label.equals("max")) {
				if (value instanceof Integer) {
					pmax = (Integer) value;
				} else {
					throw new ASTException("The max attribute should be an integer");
				}
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")? {
		p = current.createPlace(token.image, pmax);
	}
}

void ExpTransDeclaration() throws ASTException: {
	Token token;
	PairValueList optlist;
	ExpTrans tr;
} {
	<EXPTRANS> token = <IDENTIFIER> {
		tr = current.createExpTrans(token.image,
			new ASTVariable(token.image + ".rate"));
		tr.setGuard(new ASTVariable(token.image + ".guard"));
		current.put(token.image + ".rate", new ASTValue(token.image + ".rate"));
		current.put(token.image + ".guard", new ASTValue(true));
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			if (label.equals("rate")) {
				current.put(token.image + ".rate", value);
			} else if (label.equals("guard")) {
				current.put(token.image + ".guard", value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void ImmTransDeclaration() throws ASTException: {
	Token token;
	PairValueList optlist;
	ImmTrans tr;
} {
	<IMMTRANS> token = <IDENTIFIER> {
		tr = current.createImmTrans(token.image,
			new ASTVariable(token.image + ".weight"));
		tr.setGuard(new ASTVariable(token.image + ".guard"));
		current.put(token.image + ".guard", new ASTValue(true));
    tr.setPriority(0);
    tr.setVanishable(false);
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			if (label.equals("weight")) {
				current.put(token.image + ".weight", value);
			} else if (label.equals("guard")) {
				current.put(token.image + ".guard", value);
			} else if (label.equals("priority")) {
        Object obj = value.eval(current);
        if (obj instanceof Integer) {
          tr.setPriority((Integer) obj);
        } else {
          throw new ASTException("The priority attribute should be an integer.");
        }
      } else if (label.equals("vanishing")) {
        Object obj = value.eval(current);
        if (obj instanceof Boolean) {
          tr.setVanishable((Boolean) obj);
        } else {
          throw new ASTException("The vanishing attribute should be a boolean.");
        }
      } else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void GenTransDeclaration() throws ASTException: {
	Token token;
	PairValueList optlist;
} {
	<GENTRANS> token = <IDENTIFIER> {
		current.createGenTrans(token.image,
		new ASTVariable(token.image + ".dist"), GenTrans.DefaultPolicy);
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			GenTrans tr = (GenTrans) current.get(token.image);
			if (label.equals("dist")) {
				current.put(token.image + ".dist", value);
			} else if (label.equals("policy")) {
				Object v = value.eval(current);
				if (v instanceof Integer) {
					int pol = ((Integer) v).intValue();
					if (pol == 0) {
						tr.setPolicy(GenTransPolicy.PRD);
					} else if (pol == 1) {
						tr.setPolicy(GenTransPolicy.PRS);
					} else {
						throw new UnknownOption("Unknown policy");
					}
				} else {
					throw new UnknownOption("Unknown policy");
				}
			} else if (label.equals("guard")) {
				tr.setGuard(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void GenConstTransDeclaration() throws ASTException: {
	Token token;
	PairValueList optlist;
} {
	<GENCONSTTRANS> token = <IDENTIFIER> {
		current.createGenTrans(token.image, new ASTVariable(token.image + ".dist"), GenTrans.DefaultPolicy);
		current.put(token.image + ".dist", new ConstDist(new ASTValue("value")));
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			GenTrans tr = (GenTrans) current.get(token.image);
			ConstDist dist = (ConstDist) current.get(token.image + ".dist");
			if (label.equals("value")) {
				dist.setConstValue(value);
			} else if (label.equals("policy")) {
				Object v = value.eval(current);
				if (v instanceof Integer) {
					int pol = ((Integer) v).intValue();
					if (pol == 0) {
						tr.setPolicy(GenTransPolicy.PRD);
					} else if (pol == 1) {
						tr.setPolicy(GenTransPolicy.PRS);
					} else {
						throw new UnknownOption(label);
					}
				} else {
					throw new UnknownOption(label);
				}
			} else if (label.equals("guard")) {
				tr.setGuard(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void GenUnifTransDeclaration() throws ASTException: {
	Token token;
	PairValueList optlist;
} {
	<GENUNIFTRANS> token = <IDENTIFIER> {
		current.createGenTrans(token.image, new ASTVariable(token.image + ".dist"), GenTrans.DefaultPolicy);
		current.put(token.image + ".dist", new UnifDist(new ASTValue("lower"), new ASTValue("upper")));
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			GenTrans tr = (GenTrans) current.get(token.image);
			UnifDist dist = (UnifDist) current.get(token.image + ".dist");
			if (label.equals("lower")) {
				dist.setLower(value);
			} else if (label.equals("upper")) {
				dist.setUpper(value);
			} else if (label.equals("policy")) {
				Object v = value.eval(current);
				if (v instanceof Integer) {
					int pol = ((Integer) v).intValue();
					if (pol == 0) {
						tr.setPolicy(GenTransPolicy.PRD);
					} else if (pol == 1) {
						tr.setPolicy(GenTransPolicy.PRS);
					} else {
						throw new UnknownOption(label);
					}
				} else {
					throw new UnknownOption(label);
				}
			} else if (label.equals("guard")) {
				tr.setGuard(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void ArcDeclaration() throws ASTException: {
	Token src;
	Token dest;
	PairValueList optlist;
	ArcBase a;
} {
	<ARC> src = <IDENTIFIER> { } <TO> dest = <IDENTIFIER> {
		Object s, d;
		try {
			s = current.get(src.image);
			d = current.get(dest.image);
		} catch (NotFindObjectException e) {
			throw new NotFindObjectException("Did not find " + src.image + " -> " + dest.image);
		}
		try {
			if (s instanceof Place && d instanceof Trans) {
				a = current.createNormalInArc((Place) s, (Trans) d, new ASTValue(1));
			} else if (s instanceof Trans && d instanceof Place) {
				a = current.createNormalOutArc((Trans) s, (Place) d, new ASTValue(1));
			} else {
				throw new ASTException("Error: An arc should be Place to Trans or Trans to Place " + src.image + " -> " + dest.image);
			}
		} catch (AlreadyExistException e3) {
			throw new AlreadyExistException("Already exist the arc " + src.image + " -> " + dest.image);
		}
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			if (label.equals("multi")) {
				a.setMulti(value);
			} else if (label.equals("firing")) {
				a.setFiring(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void IArcDeclaration() throws ASTException: {
	Token src;
	Token dest;
	PairValueList optlist;
	ArcBase a;
} {
	<IARC> src = <IDENTIFIER> { } <TO> dest = <IDENTIFIER> {
		Place p = (Place) current.get(src.image);
		Trans tr = (Trans) current.get(dest.image);
		a = current.createNormalInArc(p, tr, new ASTValue(1));
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			if (label.equals("multi")) {
				a.setMulti(value);
			} else if (label.equals("firing")) {
				a.setFiring(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void OArcDeclaration() throws ASTException: {
	Token src;
	Token dest;
	PairValueList optlist;
	ArcBase a;
} {
	<OARC> src = <IDENTIFIER> { } <TO> dest = <IDENTIFIER> {
		Place p = (Place) current.get(dest.image);
		Trans tr = (Trans) current.get(src.image);
		a = current.createNormalOutArc(tr, p, new ASTValue(1));
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			if (label.equals("multi")) {
				a.setMulti(value);
			} else if (label.equals("firing")) {
				a.setFiring(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

void HArcDeclaration() throws ASTException: {
	Token src;
	Token dest;
	PairValueList optlist;
	ArcBase a;
} {
	<HARC> src = <IDENTIFIER> { } <TO> dest = <IDENTIFIER> {
		Place p = (Place) current.get(src.image);
		Trans tr = (Trans) current.get(dest.image);
		a = current.createInhibitArc(p, tr, new ASTValue(1));
	} ("(" optlist = OptionList() {
		for (PairValue pval : optlist.getList()) {
			String label = pval.getLabel();
			AST value = pval.getValue();
			if (label.equals("multi")) {
				a.setMulti(value);
			} else {
				throw new UnknownOption(label);
			}
		}
	}
	")")?
}

PairValueList OptionList() throws ASTException: {
	PairValueList optlist;
	PairValue val;
} {
	val = OptionValue() {
		optlist = new PairValueList();
		optlist.add(val);
	} ("," val = OptionValue() {
		optlist.add(val);
	} )* {
		return optlist;
	}
}

PairValue OptionValue() throws ASTException: {
	Token token;
	AST val;
}{
	token = <IDENTIFIER>
	"="
	val = Expression() {
		return new PairValue(token.image, val);
	}
}

AST getAST() throws ASTException: {
	AST val;
} {
	val = Expression() (<SEND> | <EOF>) {
		return val;
	}
}

void getASTTest() throws ASTException: {
	AST val;
} {
	(val = Expression() {
		System.out.println(val.eval(current));
	} (<SEND> | <NL> | <EOF>))* { }
}

/////
AST Expression() throws ASTException: {
	AST val;
} {
	(LOOKAHEAD(2) val = AssignExpression()
	| val = OrExpression()) {
		return val;
	}
}

AST AssignExpression() throws ASTException: {
	Token token;
	AST val;
} {
	token = <IDENTIFIER> { }
	(":=" val = Expression() { }
	| "=" val = Expression() { })
/*	| "=" val = Expression() {
		Object result = val.eval(current);
		if (result instanceof Integer) {
			val = new ASTValue((Integer) result);
		} else if (result instanceof Double) {
			val = new ASTValue((Double) result);
		} else if (result instanceof Boolean) {
			val = new ASTValue((Boolean) result);
		} else {
			val = null;
		}
	}) */
	{
		current.put(token.image, val);
		return val;
	}
}

AST OrExpression() throws ASTException: {
	AST val1;
	AST val2;
} {
	val1 = AndExpression() (
		<OR> val2 = AndExpression() {
			val1 = new ASTLogical(val1, val2, "||");
		}
	)* {
		return val1;
	}
}

AST AndExpression() throws ASTException: {
	AST val1;
	AST val2;
} {
	val1 = EqExpression() (
		<AND> val2 = EqExpression() {
			val1 = new ASTLogical(val1, val2, "&&");
		}
	)* {
		return val1;
	}
}

AST EqExpression() throws ASTException: {
	AST val1;
	AST val2;
} {
	val1 = CompareExpression() (
		<EQ> val2 = CompareExpression() {
			val1 = new ASTComparator(val1, val2, "==");
		}
		| <NEQ> val2 = CompareExpression() {
			val1 = new ASTComparator(val1, val2, "!=");
		}
	)* {
		return val1;
	}
}

AST CompareExpression() throws ASTException: {
	AST val1;
	AST val2;
} {
	val1 = TermExpression() (
		<GT> val2 = TermExpression() {
			val1 = new ASTComparator(val1, val2, ">");
		}
		| <GTE> val2 = TermExpression() {
			val1 = new ASTComparator(val1, val2, ">=");
		}
		| <LT> val2 = TermExpression() {
			val1 = new ASTComparator(val1, val2, "<");
		}
		| <LTE> val2 = TermExpression() {
			val1 = new ASTComparator(val1, val2, "<=");
		}
	)* {
		return val1;
	}
}

AST TermExpression() throws ASTException: {
	AST val1;
	AST val2;
} {
	val1 = MultiplyExpression() (
		<PLUS> val2 = MultiplyExpression() {
			val1 = new ASTArithmetic(val1, val2, "+");
		}
		| <MINUS> val2 = MultiplyExpression() {
			val1 = new ASTArithmetic(val1, val2, "-");
		}
	)* {
		return val1;
	}
}

AST MultiplyExpression() throws ASTException: {
	AST val1;
	AST val2;
} {
	val1 = Factor() (
		<MULTIPLY> val2 = Factor() {
			val1 = new ASTArithmetic(val1, val2, "*");
		}
		| <DIVIDE> val2 = Factor() {
			val1 = new ASTArithmetic(val1, val2, "/");
		}
		| <MOD> val2 = Factor() {
			val1 = new ASTArithmetic(val1, val2, "%");
		}
	)* {
		return val1;
	}
}

AST Factor() throws ASTException: {
	AST val1;
} {
	val1 = PrimaryExpression() {
		return val1;
	}
	| <NOT> val1 = PrimaryExpression() {
		return new ASTUnary(val1, "!");
	}
	| <PLUS> val1 = PrimaryExpression() {
		return val1;
	}
	| <MINUS> val1 = PrimaryExpression() {
		return new ASTUnary(val1, "-");
	}
}

AST PrimaryExpression() throws ASTException: {
	AST val1, val2, val3;
	Token token;
} {
	token = <INTEGER> {
		return new ASTValue(Integer.parseInt(token.image));
	}
	| token = <REAL> {
		return new ASTValue(Double.parseDouble(token.image));
	}
  | token = <BOOLEAN> {
		return new ASTValue(Boolean.parseBoolean(token.image));
	}
	| token = <STRING> {
		return new ASTValue(token.image);
	}
	| <NTOKEN> token = <IDENTIFIER> {
		return new ASTNumOfToken((Place) current.get(token.image));
	}
	| <GLOBAL_NTOKEN> token = <IDENTIFIER> {
		return new ASTNumOfToken((Place) global.get(token.image));
	}
  | <ECOND> token = <IDENTIFIER> {
		return new ASTEnableCond((Trans) current.get(token.image));
	}
	| token = <IDENTIFIER> {
		return new ASTVariable(token.image);
	}
	| (<IFELSE> "(" val1 = Expression() "," val2 = Expression() "," val3 = Expression() ")") {
		return new ASTTernary(val1, val2, val3, "ite");
	}
	| (<OPEN> val1 = Expression() <CLOSE>) {
		return val1;
	}
}
